<!-- Written by: Yun Yan (https://github.com/Puriney) -->

# Identifying subclones

**Full R script**: <kbd>scripts/annotate_conda.pipe.R</kbd> ([link](https://github.com/navinlabcode/wellDA-seq/tree/main/tutorial/scripts/annotate_conda.pipe.R))

**Rationale**: Compared to the cell line scDNA-seq data, the tissue data is a mixture of diploid and aneuploid cells. A simple filtering based on some threshold would be likely to miss the rare cell populations with small CNA events. These rare cells could also be the cancer progenitor cells. Because the CNA events are small and the frequencies of these cells are low, their signals might not be able to stand out and could be wrongly classified as noisy or diploid cells. Therefore, we suggest look into the tentative diploid and aneuploid cells separately. Although these rare aneuploid cells could also be the diploid-aneuploid doublets and low-quality aneuploid cells, we can still identify and remove them based some strategies: 1) [scquantum](https://github.com/navinlabcode/scquantum) and 2) referring to the ATAC data. 


## 1. Split the cells into the tentative diploid and aneuploid populations

```R
f_a       <- 'obja.rds'
f_d       <- 'objd.rds'
df_meta   <- 'metadata.df.rds'
obja      <- read_rds(f_a)
objd      <- read_rds(f_d)
df_meta   <- read_rds(f_meta)
```

Tentatively determine the cells if they are diploid or aneuploid by using Copykit's function `findAneuploidCells`. 

```R
objd <- findAneuploidCells(objd, resolution = 'auto')
try(objd[['ploidy_class']] <- ifelse(objd[['is_aneuploid']], 'aneuploid', 'diploid'))
table(objd[['ploidy_class']], useNA='always')
## backup
objd0 <- objd; df_meta0 <- df_meta; obja0 <- obja
for (z in c('diploid', 'aneuploid')) {
  dir_snippet <- 'CNA_processing_ploidy_class', z)
  fs::dir_create(dir_snippet)
  tmp <- objd0[['ploidy_class']] == z; message(z, ' has ', sum(tmp), ' cells.')
  write_rds(objd0[, tmp], file.path(dir_snippet, 'objd.rds'))
  write_rds(obja0[, tmp], file.path(dir_snippet, 'obja.rds'))
  write_rds(df_meta0[tmp, ], file.path(dir_snippet, 'metadata.df.rds'))
}
```


Technical preprations. 

```R
#------ reclustering ------
for (cna_ploidy_class in c('diploid', 'aneuploid')) {
# for (cna_ploidy_class in c('diploid')) {
  message(cna_ploidy_class)
  dir_snippet <- file.path(dir_proj, 'CNA_processing_ploidy_class', cna_ploidy_class)
  load_coda(dir_snippet)
  print(ncol(objd))
  if (cna_ploidy_class == 'aneuploid') {
    source('./rsrc/snippet.CNA_clustering_in_aneuploid.R')
  } else {
    source('./rsrc/snippet.CNA_clustering_in_diploid.R')
  }
```

```R
#------ rerun scquantume ------
for (cna_ploidy_class in c('diploid', 'aneuploid')) {
# for (cna_ploidy_class in c('diploid')) {
  message(cna_ploidy_class)
  dir_snippet <- file.path(dir_proj, 'CNA_processing_ploidy_class', cna_ploidy_class)
  load_coda(dir_snippet)
  print(ncol(objd))
  objd <- calcInteger(objd, method = 'scquantum', assay = 'bincounts',
                      name = 'integer_scquantum')
  objd <- calcInteger(objd, method = 'fixed', assay = 'segment_ratios', 
                      ploidy_value = 2, 
                      name = 'integer_fixed')  
```

## 2. Processing the tentative diploid cells

## 3. Processing the tentative aneuploid cells

## 4. Merge the diploid and aneupoid cells




